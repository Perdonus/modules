__id__ = "etg_bridge"
__name__ = "ETG Bridge (Heroku)"
__description__ = "Native bridge between Heroku modules and ETG plugins"
__author__ = "@etopizdesblin & @plugin_ai"
__version__ = "1.0.0"
__icon__ = "msg_round_link"
__min_version__ = "11.12.0"

import base64
import hashlib
import json
import os
import re
import socket
import ssl
import struct
import tempfile
import threading
import time
import traceback
import uuid
from urllib.parse import urlparse

import requests
from base_plugin import BasePlugin, HookResult, HookStrategy
from android_utils import run_on_ui_thread
from client_utils import get_last_fragment
from hook_utils import find_class
from ui.alert import AlertDialogBuilder
from ui.bulletin import BulletinHelper
from ui.settings import Header, Input, Text, Divider
from java import dynamic_proxy
from com.exteragram.messenger.plugins import PluginsController
from org.telegram.messenger import ApplicationLoader, AndroidUtilities, Utilities

from mandre_lib import (
    Mandre,
    MandreData,
    MandreUI,
    MandreTTS,
    MandreAuth,
    MandreShare,
    MandreDevice,
    MandreNotification,
    MandrePip,
    MandreWeb,
    MandreSend,
    MandreInstall,
    MandreSettings,
    MandreSuggestions,
    MandreMessages,
)

Intent = find_class("android.content.Intent")
Uri = find_class("android.net.Uri")
ClipboardManager = find_class("android.content.ClipboardManager")
ClipData = find_class("android.content.ClipData")

try:
    from android.widget import LinearLayout, EditText, ScrollView, TextView
    from android.text import InputType
    from android.view import Gravity, ViewGroup
except Exception:
    LinearLayout = find_class("android.widget.LinearLayout")
    EditText = find_class("android.widget.EditText")
    ScrollView = find_class("android.widget.ScrollView")
    TextView = find_class("android.widget.TextView")
    InputType = find_class("android.text.InputType")
    Gravity = find_class("android.view.Gravity")
    ViewGroup = find_class("android.view.ViewGroup")

DEFAULT_SERVER_URL = ""
DEFAULT_WS_URL = ""
WS_GUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"
DEFAULT_UPDATE_BRANCH = "release"
UPDATE_INTERVAL = 3600
DEFAULT_LANG = "ru"

LANG_CHOICES = [
    ("ru", "–†—É—Å—Å–∫–∏–π", "üá∑üá∫"),
    ("be", "–ë–µ–ª–∞—Ä—É—Å–∫–∞—è", "üáßüáæ"),
    ("uk", "–£–∫—Ä–∞—ó–Ω—Å—å–∫–∞", "üá∫üá¶"),
    ("kk", "“ö–∞–∑–∞“õ—à–∞", "üá∞üáø"),
    ("en", "English", "üá¨üáß"),
    ("fr", "Fran√ßais", "üá´üá∑"),
    ("ja", "Êó•Êú¨Ë™û", "üáØüáµ"),
    ("zh", "‰∏≠Êñá", "üá®üá≥"),
]

TRANSLATIONS = {
    "ru": {
        "settings_title": "ETG Bridge",
        "server_url": "URL —Å–µ—Ä–≤–µ—Ä–∞",
        "device_id": "ID —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞",
        "update_branch": "–í–µ—Ç–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π: {branch}",
        "language": "–Ø–∑—ã–∫: {lang}",
        "force_sync": "–ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–∞—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è",
        "check_updates": "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è",
        "sync_requested": "ETG bridge: —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –∑–∞–ø—Ä–æ—à–µ–Ω–∞",
        "checking_updates": "–ü—Ä–æ–≤–µ—Ä—è—é –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è...",
        "no_updates": "–ù–µ—Ç –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π: {filename}",
        "update_available": "–î–æ—Å—Ç—É–ø–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ {filename}: {current} ‚Üí {new}",
        "update_title": "–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ",
        "update_yes": "–û–±–Ω–æ–≤–∏—Ç—å",
        "update_later": "–ü–æ–∑–∂–µ",
        "branch_select_title": "–í—ã–±–æ—Ä –≤–µ—Ç–∫–∏",
        "branch_select_msg": "–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞–Ω–∞–ª –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π.",
        "branch_release": "–†–µ–ª–∏–∑",
        "branch_beta": "–ë–µ—Ç–∞",
        "lang_select_title": "–í—ã–±–æ—Ä —è–∑—ã–∫–∞",
        "lang_select_msg": "–í—ã–±–µ—Ä–∏—Ç–µ —è–∑—ã–∫ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞.",
        "lang_saved": "–Ø–∑—ã–∫: {lang}",
        "close": "–ó–∞–∫—Ä—ã—Ç—å",
        "ok": "–û–ö",
        "cancel": "–û—Ç–º–µ–Ω–∞",
    },
    "be": {
        "settings_title": "ETG Bridge",
        "server_url": "URL —Å–µ—Ä–≤–µ—Ä–∞",
        "device_id": "ID –ø—Ä—ã–ª–∞–¥—ã",
        "update_branch": "–ì–∞–ª—ñ–Ω–∫–∞ –∞–±–Ω–∞—û–ª–µ–Ω–Ω—è—û: {branch}",
        "language": "–ú–æ–≤–∞: {lang}",
        "force_sync": "–ü—Ä—ã–º—É—Å–æ–≤–∞—è —Å—ñ–Ω—Ö—Ä–∞–Ω—ñ–∑–∞—Ü—ã—è",
        "check_updates": "–ü—Ä–∞–≤–µ—Ä—ã—Ü—å –∞–±–Ω–∞—û–ª–µ–Ω–Ω—ñ",
        "sync_requested": "ETG bridge: —Å—ñ–Ω—Ö—Ä–∞–Ω—ñ–∑–∞—Ü—ã—è –∑–∞–ø—ã—Ç–∞–Ω–∞",
        "checking_updates": "–ü—Ä–∞–≤—è—Ä–∞—é –∞–±–Ω–∞—û–ª–µ–Ω–Ω—ñ...",
        "no_updates": "–ù—è–º–∞ –∞–±–Ω–∞—û–ª–µ–Ω–Ω—è—û: {filename}",
        "update_available": "–Å—Å—Ü—å –∞–±–Ω–∞—û–ª–µ–Ω–Ω–µ {filename}: {current} ‚Üí {new}",
        "update_title": "–ê–±–Ω–∞—û–ª–µ–Ω–Ω–µ",
        "update_yes": "–ê–±–Ω–∞–≤—ñ—Ü—å",
        "update_later": "–ü–∞–∑–Ω–µ–π",
        "branch_select_title": "–í—ã–±–∞—Ä –≥–∞–ª—ñ–Ω–∫—ñ",
        "branch_select_msg": "–í—ã–±–µ—Ä—ã—Ü–µ –∫–∞–Ω–∞–ª –∞–±–Ω–∞—û–ª–µ–Ω–Ω—è—û.",
        "branch_release": "–†—ç–ª—ñ–∑",
        "branch_beta": "–ë—ç—Ç–∞",
        "lang_select_title": "–í—ã–±–∞—Ä –º–æ–≤—ã",
        "lang_select_msg": "–í—ã–±–µ—Ä—ã—Ü–µ –º–æ–≤—É —ñ–Ω—Ç—ç—Ä—Ñ–µ–π—Å—É.",
        "lang_saved": "–ú–æ–≤–∞: {lang}",
        "close": "–ó–∞–∫—Ä—ã—Ü—å",
        "ok": "–û–ö",
        "cancel": "–ê–¥–º–µ–Ω–∞",
    },
    "uk": {
        "settings_title": "ETG Bridge",
        "server_url": "URL —Å–µ—Ä–≤–µ—Ä–∞",
        "device_id": "ID –ø—Ä–∏—Å—Ç—Ä–æ—é",
        "update_branch": "–ì—ñ–ª–∫–∞ –æ–Ω–æ–≤–ª–µ–Ω—å: {branch}",
        "language": "–ú–æ–≤–∞: {lang}",
        "force_sync": "–ü—Ä–∏–º—É—Å–æ–≤–∞ —Å–∏–Ω—Ö—Ä–æ–Ω—ñ–∑–∞—Ü—ñ—è",
        "check_updates": "–ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –æ–Ω–æ–≤–ª–µ–Ω–Ω—è",
        "sync_requested": "ETG bridge: —Å–∏–Ω—Ö—Ä–æ–Ω—ñ–∑–∞—Ü—ñ—é –∑–∞–ø–∏—Ç–∞–Ω–æ",
        "checking_updates": "–ü–µ—Ä–µ–≤—ñ—Ä—è—é –æ–Ω–æ–≤–ª–µ–Ω–Ω—è...",
        "no_updates": "–ù–µ–º–∞—î –æ–Ω–æ–≤–ª–µ–Ω—å: {filename}",
        "update_available": "–î–æ—Å—Ç—É–ø–Ω–µ –æ–Ω–æ–≤–ª–µ–Ω–Ω—è {filename}: {current} ‚Üí {new}",
        "update_title": "–û–Ω–æ–≤–ª–µ–Ω–Ω—è",
        "update_yes": "–û–Ω–æ–≤–∏—Ç–∏",
        "update_later": "–ü—ñ–∑–Ω—ñ—à–µ",
        "branch_select_title": "–í–∏–±—ñ—Ä –≥—ñ–ª–∫–∏",
        "branch_select_msg": "–û–±–µ—Ä—ñ—Ç—å –∫–∞–Ω–∞–ª –æ–Ω–æ–≤–ª–µ–Ω—å.",
        "branch_release": "–†–µ–ª—ñ–∑",
        "branch_beta": "–ë–µ—Ç–∞",
        "lang_select_title": "–í–∏–±—ñ—Ä –º–æ–≤–∏",
        "lang_select_msg": "–û–±–µ—Ä—ñ—Ç—å –º–æ–≤—É —ñ–Ω—Ç–µ—Ä—Ñ–µ–π—Å—É.",
        "lang_saved": "–ú–æ–≤–∞: {lang}",
        "close": "–ó–∞–∫—Ä–∏—Ç–∏",
        "ok": "–û–ö",
        "cancel": "–°–∫–∞—Å—É–≤–∞—Ç–∏",
    },
    "kk": {
        "settings_title": "ETG Bridge",
        "server_url": "–°–µ—Ä–≤–µ—Ä URL",
        "device_id": "“ö“±—Ä—ã–ª“ì—ã ID",
        "update_branch": "–ñ–∞“£–∞—Ä—Ç—É —Ç–∞—Ä–º–∞“ì—ã: {branch}",
        "language": "–¢—ñ–ª: {lang}",
        "force_sync": "–ú”ô–∂–±“Ø—Ä–ª—ñ —Å–∏–Ω—Ö—Ä–æ–Ω–¥–∞—É",
        "check_updates": "–ñ–∞“£–∞—Ä—Ç—É–ª–∞—Ä–¥—ã —Ç–µ–∫—Å–µ—Ä—É",
        "sync_requested": "ETG bridge: —Å–∏–Ω—Ö—Ä–æ–Ω–¥–∞—É —Å“±—Ä–∞–ª–¥—ã",
        "checking_updates": "–ñ–∞“£–∞—Ä—Ç—É–ª–∞—Ä —Ç–µ–∫—Å–µ—Ä—ñ–ª—É–¥–µ...",
        "no_updates": "–ñ–∞“£–∞—Ä—Ç—É –∂–æ“õ: {filename}",
        "update_available": "–ñ–∞“£–∞—Ä—Ç—É –±–∞—Ä {filename}: {current} ‚Üí {new}",
        "update_title": "–ñ–∞“£–∞—Ä—Ç—É",
        "update_yes": "–ñ–∞“£–∞—Ä—Ç—É",
        "update_later": "–ö–µ–π—ñ–Ω",
        "branch_select_title": "–¢–∞—Ä–º–∞“õ—Ç—ã —Ç–∞“£–¥–∞—É",
        "branch_select_msg": "–ñ–∞“£–∞—Ä—Ç—É –∞—Ä–Ω–∞—Å—ã–Ω —Ç–∞“£–¥–∞“£—ã–∑.",
        "branch_release": "–†–µ–ª–∏–∑",
        "branch_beta": "–ë–µ—Ç–∞",
        "lang_select_title": "–¢—ñ–ª–¥—ñ —Ç–∞“£–¥–∞—É",
        "lang_select_msg": "–ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å —Ç—ñ–ª—ñ–Ω —Ç–∞“£–¥–∞“£—ã–∑.",
        "lang_saved": "–¢—ñ–ª: {lang}",
        "close": "–ñ–∞–±—É",
        "ok": "–û–ö",
        "cancel": "–ë–æ–ª–¥—ã—Ä–º–∞—É",
    },
    "en": {
        "settings_title": "ETG Bridge",
        "server_url": "Server URL",
        "device_id": "Device ID",
        "update_branch": "Update branch: {branch}",
        "language": "Language: {lang}",
        "force_sync": "Force sync",
        "check_updates": "Check updates",
        "sync_requested": "ETG bridge: sync requested",
        "checking_updates": "Checking updates...",
        "no_updates": "No updates: {filename}",
        "update_available": "Update available {filename}: {current} ‚Üí {new}",
        "update_title": "Update",
        "update_yes": "Update",
        "update_later": "Later",
        "branch_select_title": "Select branch",
        "branch_select_msg": "Choose update channel.",
        "branch_release": "Release",
        "branch_beta": "Beta",
        "lang_select_title": "Select language",
        "lang_select_msg": "Choose interface language.",
        "lang_saved": "Language: {lang}",
        "close": "Close",
        "ok": "OK",
        "cancel": "Cancel",
    },
    "fr": {
        "settings_title": "ETG Bridge",
        "server_url": "URL du serveur",
        "device_id": "ID de l'appareil",
        "update_branch": "Branche de mise √† jour : {branch}",
        "language": "Langue : {lang}",
        "force_sync": "Forcer la synchro",
        "check_updates": "V√©rifier les mises √† jour",
        "sync_requested": "ETG bridge : synchro demand√©e",
        "checking_updates": "Recherche des mises √† jour...",
        "no_updates": "Aucune mise √† jour : {filename}",
        "update_available": "Mise √† jour dispo {filename} : {current} ‚Üí {new}",
        "update_title": "Mise √† jour",
        "update_yes": "Mettre √† jour",
        "update_later": "Plus tard",
        "branch_select_title": "Choisir la branche",
        "branch_select_msg": "Choisissez le canal de mise √† jour.",
        "branch_release": "Release",
        "branch_beta": "B√™ta",
        "lang_select_title": "Choisir la langue",
        "lang_select_msg": "Choisissez la langue de l'interface.",
        "lang_saved": "Langue : {lang}",
        "close": "Fermer",
        "ok": "OK",
        "cancel": "Annuler",
    },
    "ja": {
        "settings_title": "ETG Bridge",
        "server_url": "„Çµ„Éº„Éê„ÉºURL",
        "device_id": "„Éá„Éê„Ç§„ÇπID",
        "update_branch": "Êõ¥Êñ∞„Éñ„É©„É≥„ÉÅ: {branch}",
        "language": "Ë®ÄË™û: {lang}",
        "force_sync": "Âº∑Âà∂ÂêåÊúü",
        "check_updates": "Êõ¥Êñ∞„ÇíÁ¢∫Ë™ç",
        "sync_requested": "ETG bridge: ÂêåÊúüË¶ÅÊ±Ç",
        "checking_updates": "Êõ¥Êñ∞„ÇíÁ¢∫Ë™ç‰∏≠...",
        "no_updates": "Êõ¥Êñ∞„Å™„Åó: {filename}",
        "update_available": "Êõ¥Êñ∞„ÅÇ„Çä {filename}: {current} ‚Üí {new}",
        "update_title": "Êõ¥Êñ∞",
        "update_yes": "Êõ¥Êñ∞„Åô„Çã",
        "update_later": "Âæå„Åß",
        "branch_select_title": "„Éñ„É©„É≥„ÉÅÈÅ∏Êäû",
        "branch_select_msg": "Êõ¥Êñ∞„ÉÅ„É£„Éç„É´„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
        "branch_release": "„É™„É™„Éº„Çπ",
        "branch_beta": "„Éô„Éº„Çø",
        "lang_select_title": "Ë®ÄË™ûÈÅ∏Êäû",
        "lang_select_msg": "„Ç§„É≥„Çø„Éº„Éï„Çß„Éº„ÇπË®ÄË™û„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
        "lang_saved": "Ë®ÄË™û: {lang}",
        "close": "Èñâ„Åò„Çã",
        "ok": "OK",
        "cancel": "„Ç≠„É£„É≥„Çª„É´",
    },
    "zh": {
        "settings_title": "ETG Bridge",
        "server_url": "ÊúçÂä°Âô®URL",
        "device_id": "ËÆæÂ§áID",
        "update_branch": "Êõ¥Êñ∞ÂàÜÊîØ: {branch}",
        "language": "ËØ≠Ë®Ä: {lang}",
        "force_sync": "Âº∫Âà∂ÂêåÊ≠•",
        "check_updates": "Ê£ÄÊü•Êõ¥Êñ∞",
        "sync_requested": "ETG bridge: Â∑≤ËØ∑Ê±ÇÂêåÊ≠•",
        "checking_updates": "Ê≠£Âú®Ê£ÄÊü•Êõ¥Êñ∞...",
        "no_updates": "ÊöÇÊó†Êõ¥Êñ∞: {filename}",
        "update_available": "ÊúâÂèØÁî®Êõ¥Êñ∞ {filename}: {current} ‚Üí {new}",
        "update_title": "Êõ¥Êñ∞",
        "update_yes": "Êõ¥Êñ∞",
        "update_later": "Á®çÂêé",
        "branch_select_title": "ÈÄâÊã©ÂàÜÊîØ",
        "branch_select_msg": "ËØ∑ÈÄâÊã©Êõ¥Êñ∞ÈÄöÈÅì„ÄÇ",
        "branch_release": "Ê≠£ÂºèÁâà",
        "branch_beta": "ÊµãËØïÁâà",
        "lang_select_title": "ÈÄâÊã©ËØ≠Ë®Ä",
        "lang_select_msg": "ËØ∑ÈÄâÊã©ÁïåÈù¢ËØ≠Ë®Ä„ÄÇ",
        "lang_saved": "ËØ≠Ë®Ä: {lang}",
        "close": "ÂÖ≥Èó≠",
        "ok": "OK",
        "cancel": "ÂèñÊ∂à",
    },
}


class _Callback1(dynamic_proxy(Utilities.Callback)):
    def __init__(self, fn):
        super().__init__()
        self._fn = fn

    def run(self, arg):
        try:
            self._fn(arg)
        except Exception:
            pass


class _WSClient:
    def __init__(self, url):
        self.url = url
        self.sock = None
        self.lock = threading.Lock()
        self.alive = False
        self._connect()

    def _connect(self):
        parsed = urlparse(self.url)
        scheme = parsed.scheme.lower()
        if scheme not in {"ws", "wss"}:
            raise ValueError("ws url must start with ws:// or wss://")
        host = parsed.hostname or ""
        port = parsed.port or (443 if scheme == "wss" else 80)
        path = parsed.path or "/"
        if parsed.query:
            path = f"{path}?{parsed.query}"

        sock = socket.create_connection((host, port), timeout=10)
        if scheme == "wss":
            ctx = ssl._create_unverified_context()
            sock = ctx.wrap_socket(sock, server_hostname=host)
        key = base64.b64encode(os.urandom(16)).decode("ascii")
        headers = [
            f"GET {path} HTTP/1.1",
            f"Host: {host}:{port}",
            "Upgrade: websocket",
            "Connection: Upgrade",
            f"Sec-WebSocket-Key: {key}",
            "Sec-WebSocket-Version: 13",
            "\r\n",
        ]
        sock.sendall("\r\n".join(headers).encode("utf-8"))
        data = b""
        sock.settimeout(10)
        while b"\r\n\r\n" not in data:
            chunk = sock.recv(4096)
            if not chunk:
                raise RuntimeError("ws handshake failed")
            data += chunk
            if len(data) > 8192:
                raise RuntimeError("ws handshake too large")
        header = data.split(b"\r\n\r\n", 1)[0].decode("utf-8", "ignore")
        if " 101 " not in header:
            raise RuntimeError(f"ws handshake rejected: {header.splitlines()[0]}")
        accept_expected = base64.b64encode(
            hashlib.sha1(f"{key}{WS_GUID}".encode("utf-8")).digest()
        ).decode("ascii")
        if accept_expected not in header:
            raise RuntimeError("ws handshake invalid accept")
        sock.settimeout(None)
        self.sock = sock
        self.alive = True

    def close(self):
        self.alive = False
        try:
            if self.sock:
                self.sock.close()
        except Exception:
            pass

    def _recv_exact(self, size, timeout):
        if not self.sock:
            raise RuntimeError("ws socket closed")
        self.sock.settimeout(timeout)
        data = b""
        while len(data) < size:
            try:
                chunk = self.sock.recv(size - len(data))
            except socket.timeout:
                raise TimeoutError()
            if not chunk:
                raise ConnectionError("ws closed")
            data += chunk
        return data

    def _send_frame(self, opcode, payload):
        if not self.sock or not self.alive:
            return
        payload = payload or b""
        length = len(payload)
        header = bytearray()
        header.append(0x80 | (opcode & 0x0F))
        mask_bit = 0x80
        if length <= 125:
            header.append(mask_bit | length)
        elif length < 65536:
            header.append(mask_bit | 126)
            header.extend(struct.pack("!H", length))
        else:
            header.append(mask_bit | 127)
            header.extend(struct.pack("!Q", length))
        mask = os.urandom(4)
        masked = bytes(b ^ mask[i % 4] for i, b in enumerate(payload))
        with self.lock:
            self.sock.sendall(header + mask + masked)

    def send_text(self, text):
        self._send_frame(0x1, text.encode("utf-8"))

    def send_json(self, payload):
        self.send_text(json.dumps(payload, ensure_ascii=True))

    def send_ping(self):
        self._send_frame(0x9, b"ping")

    def recv_text(self, timeout=1.0):
        if not self.alive:
            return None
        try:
            header = self._recv_exact(2, timeout)
        except TimeoutError:
            return None
        b1, b2 = header[0], header[1]
        opcode = b1 & 0x0F
        masked = (b2 & 0x80) != 0
        length = b2 & 0x7F
        if length == 126:
            length = struct.unpack("!H", self._recv_exact(2, timeout))[0]
        elif length == 127:
            length = struct.unpack("!Q", self._recv_exact(8, timeout))[0]
        mask = b""
        if masked:
            mask = self._recv_exact(4, timeout)
        payload = self._recv_exact(length, timeout) if length else b""
        if masked and mask:
            payload = bytes(b ^ mask[i % 4] for i, b in enumerate(payload))
        if opcode == 0x8:
            self.alive = False
            return None
        if opcode == 0x9:
            self._send_frame(0xA, payload)
            return ""
        if opcode == 0xA:
            return ""
        if opcode != 0x1:
            return ""
        return payload.decode("utf-8", "ignore")


class EtgBridgePlugin(BasePlugin):

    def __init__(self):
        super().__init__()
        self._stop = threading.Event()
        self._thread = None
        self._update_thread = None
        self._last_update_check = 0.0
        self._lock = threading.Lock()
        self._pending_logs = []
        self._pending_results = []
        self._last_status = "idle"
        self._last_error = ""
        self._last_transport = "http"
        self._ws = None
        self._ws_next_sync = 0.0
        self._ws_last_ping = 0.0
        self._ws_failures = 0
        self._ws_backoff_until = 0.0
        self._ws_last_error_at = 0.0
        self._ws_last_http = 0.0
        self._sheets = {}
        self._sheet_lock = threading.Lock()

    def on_plugin_load(self):
        self._ensure_parse_html()
        Mandre.use_persistent_storage(self)
        self.add_on_send_message_hook()
        Mandre.register_command(self, "etg", self.cmd_etg)
        try:
            MandreSettings._dsl_cache.pop(self.id, None)
            MandreSettings._plugin_ref.pop(self.id, None)
        except Exception:
            pass

        lang = (self.get_setting("lang") or DEFAULT_LANG).strip().lower()
        if lang not in TRANSLATIONS:
            lang = DEFAULT_LANG
        if self.get_setting("lang") != lang:
            self.set_setting("lang", lang)

        device_id = (self.get_setting("device_id") or "").strip()
        if not device_id:
            device_id = uuid.uuid4().hex
            self.set_setting("device_id", device_id)

        self._start_worker()
        self._start_update_worker()
        threading.Thread(target=self._startup_update_check, daemon=True).start()

    def _ensure_parse_html(self):
        import re

        def _parse_html(html):
            match = re.search(r"<\w+\s*([^>/]*)/?\s*>", html or "")
            attrs = match.group(1) if match else ""
            result = {}
            for key, value in re.findall(r"([a-zA-Z0-9_:-]+)\s*=\s*['\"](.*?)['\"]", attrs):
                result[key] = value
            if "text" not in result and "id" in result:
                result["text"] = result["id"]
            return [result]

        MandreSettings._parse_html = staticmethod(_parse_html)

    def _get_lang(self):
        lang = (self.get_setting("lang") or DEFAULT_LANG).strip().lower()
        if lang not in TRANSLATIONS:
            lang = DEFAULT_LANG
        return lang

    def _t(self, key, **kwargs):
        lang = self._get_lang()
        text = TRANSLATIONS.get(lang, {}).get(key) or TRANSLATIONS[DEFAULT_LANG].get(key) or key
        try:
            return text.format(**kwargs)
        except Exception:
            return text

    @staticmethod
    def _format_lang_label(lang):
        for code, title, flag in LANG_CHOICES:
            if code == lang:
                return f"{flag} {title}"
        return lang

    def select_language_ui(self, *_):
        items = [f"{flag} {title}" for _code, title, flag in LANG_CHOICES]

        def on_select(index, _text):
            if index < 0 or index >= len(LANG_CHOICES):
                return
            code, title, flag = LANG_CHOICES[index]
            self.set_setting("lang", code)
            try:
                Mandre.apply_and_refresh_settings(self)
            except Exception:
                pass
            BulletinHelper.show_success(self._t("lang_saved", lang=f"{flag} {title}"))

        run_on_ui_thread(
            lambda: MandreUI.show(
                self._t("lang_select_title"),
                items,
                on_select,
                message=self._t("lang_select_msg"),
                cancel_text=self._t("close"),
            )
        )

    def on_plugin_unload(self):
        self._stop.set()
        self._close_ws()
        if self._thread:
            try:
                self._thread.join(timeout=2)
            except Exception:
                pass
        self._thread = None
        if self._update_thread:
            try:
                self._update_thread.join(timeout=2)
            except Exception:
                pass
        self._update_thread = None

    def on_send_message_hook(self, params):
        return Mandre.handle_outgoing_command(params) or HookResult()

    def cmd_etg(self, plugin, args, params):
        args = (args or "").strip().lower()
        if args in {"sync", "ping"}:
            self._force_sync()
            params["message"] = self._t("sync_requested")
            return HookResult(strategy=HookStrategy.MODIFY, params=params)
        status = self._format_status()
        params["message"] = status
        return HookResult(strategy=HookStrategy.MODIFY, params=params)

    def create_settings(self):
        device_id = self.get_setting("device_id", "")
        server_url = self._get_server_url()
        branch = (self.get_setting("update_branch", "release") or "release").lower()
        branch_title = self._format_branch_title(branch)
        lang_label = self._format_lang_label(self._get_lang())
        return [
            Header(text=self._t("settings_title")),
            Input(key="server_url", text=self._t("server_url"), default=server_url, icon="msg_link"),
            Input(key="device_id", text=self._t("device_id"), default=device_id, icon="msg_profile"),
            Text(
                text=self._t("update_branch", branch=branch_title),
                icon="msg_settings_solar",
                accent=True,
                on_click=self.select_branch_ui,
            ),
            Text(
                text=self._t("language", lang=lang_label),
                icon="msg_settings_solar",
                accent=True,
                on_click=self.select_language_ui,
            ),
            Divider(),
            Text(text=self._t("force_sync"), icon="msg_refresh", accent=True, on_click=self.force_sync_ui),
            Text(text=self._t("check_updates"), icon="msg_update", accent=True, on_click=self.force_update_ui),
        ]

    def force_sync_ui(self, *_):
        self._force_sync()
        BulletinHelper.show_info(self._t("sync_requested"))

    def force_update_ui(self, *_):
        BulletinHelper.show_info(self._t("checking_updates"))
        threading.Thread(target=lambda: self._check_updates(manual=True), daemon=True).start()

    def _startup_update_check(self):
        time.sleep(3)
        try:
            self._check_updates(manual=True, silent=True)
        except Exception:
            pass

    def _format_branch_title(self, branch):
        return self._t("branch_release") if branch == "release" else self._t("branch_beta")

    def select_branch_ui(self, *_):
        current = self._get_update_branch()
        items = [self._t("branch_release"), self._t("branch_beta")]

        def on_select(index, text):
            branch = "release" if index == 0 else "beta"
            self.set_setting("update_branch", branch)
            try:
                Mandre.apply_and_refresh_settings(self)
            except Exception:
                pass
            if branch != current:
                BulletinHelper.show_success(self._t("update_branch", branch=text))

        run_on_ui_thread(
            lambda: MandreUI.show(
                self._t("branch_select_title"),
                items,
                on_select,
                message=self._t("branch_select_msg"),
                cancel_text=self._t("update_later"),
            )
        )

    def _start_update_worker(self):
        if self._update_thread and self._update_thread.is_alive():
            return
        self._update_thread = threading.Thread(target=self._update_loop, daemon=True)
        self._update_thread.start()

    def _update_loop(self):
        while not self._stop.is_set():
            now = time.time()
            if now - self._last_update_check >= UPDATE_INTERVAL:
                self._last_update_check = now
                try:
                    self._check_updates(manual=False)
                except Exception:
                    pass
            time.sleep(5)

    def _get_update_branch(self):
        branch = (self.get_setting("update_branch", DEFAULT_UPDATE_BRANCH) or DEFAULT_UPDATE_BRANCH).strip().lower()
        if branch not in {"release", "beta"}:
            branch = DEFAULT_UPDATE_BRANCH
        return branch

    def _get_server_url(self):
        return str(self.get_setting("server_url", DEFAULT_SERVER_URL) or DEFAULT_SERVER_URL).strip()

    def _get_ws_url(self):
        ws_url = str(self.get_setting("ws_url", DEFAULT_WS_URL) or DEFAULT_WS_URL).strip()
        if ws_url:
            return ws_url
        server_url = self._get_server_url()
        if not server_url:
            return ""
        parsed = urlparse(server_url)
        scheme = (parsed.scheme or "").lower()
        if scheme not in {"http", "https"}:
            return ""
        ws_scheme = "wss" if scheme == "https" else "ws"
        host = parsed.hostname or ""
        if not host:
            return ""
        netloc = f"{host}:{parsed.port}" if parsed.port else host
        path = parsed.path or ""
        if path.endswith("/sync"):
            path = f"{path[:-5]}/ws"
        else:
            path = "/ws"
        return f"{ws_scheme}://{netloc}{path}"

    def _get_update_base(self):
        server_url = self._get_server_url()
        if "/sync" in server_url:
            base = server_url.split("/sync", 1)[0]
        else:
            base = server_url.rsplit("/", 1)[0] if "/" in server_url else server_url
        return base.rstrip("/")

    def _build_update_url(self, filename):
        base = self._get_update_base()
        branch = self._get_update_branch()
        return f"{base}/etg/{branch}/{filename}"

    @staticmethod
    def _parse_version(text):
        if not text:
            return ()
        match = re.search(r"__version__\\s*=\\s*['\\\"]([^'\\\"]+)['\\\"]", text)
        if not match:
            return ()
        parts = re.findall(r"\\d+", match.group(1))
        return tuple(int(p) for p in parts) if parts else ()

    @staticmethod
    def _compare_versions(a, b):
        return (a > b) - (a < b)

    def _get_plugin_version(self, plugin_id, fallback=""):
        try:
            plugin = PluginsController.getInstance().plugins.get(plugin_id)
        except Exception:
            plugin = None
        if not plugin:
            return fallback
        try:
            return str(plugin.getVersion() or fallback)
        except Exception:
            try:
                return str(plugin.version or fallback)
            except Exception:
                return fallback

    def _download_text(self, url):
        try:
            try:
                requests.packages.urllib3.disable_warnings()  # type: ignore[attr-defined]
            except Exception:
                pass
            resp = requests.get(url, timeout=20, verify=False)
            if resp.status_code == 200:
                return resp.text
        except Exception as exc:
            self._queue_log(f"update download error: {exc}")
        return ""

    def _install_plugin_text(self, filename, text):
        cache_dir = str(ApplicationLoader.applicationContext.getCacheDir())
        path = os.path.join(cache_dir, filename)
        try:
            with open(path, "w", encoding="utf-8") as handle:
                handle.write(text)
        except Exception as exc:
            self._queue_log(f"update write failed: {exc}")
            return False

        def on_result(arg):
            if arg:
                BulletinHelper.show_error(f"Update error: {arg}")
            else:
                BulletinHelper.show_success(f"Updated: {filename}")

        try:
            PluginsController.getInstance().loadPluginFromFile(path, _Callback1(on_result))
        except TypeError:
            PluginsController.getInstance().loadPluginFromFile(path, None, _Callback1(on_result))
        except Exception as exc:
            self._queue_log(f"update install failed: {exc}")
            return False
        return True

    def _maybe_update(self, plugin_id, filename, current_version, manual=False, silent=False):
        url = self._build_update_url(filename)
        text = self._download_text(url)
        if not text:
            return
        remote_version = self._parse_version(text)
        local_version = self._parse_version(current_version)
        if not remote_version or self._compare_versions(remote_version, local_version) <= 0:
            if manual and not silent:
                BulletinHelper.show_info(self._t("no_updates", filename=filename))
            return

        msg = self._t(
            "update_available",
            filename=filename,
            current=current_version,
            new=".".join(map(str, remote_version)),
        )
        auto_update = bool(self.get_setting("auto_update", True))

        def do_update():
            self._install_plugin_text(filename, text)

        if auto_update and not manual:
            run_on_ui_thread(lambda: BulletinHelper.show_info(msg))
            run_on_ui_thread(do_update)
        else:
            def on_select(index, _text):
                if index == 0:
                    do_update()
            run_on_ui_thread(
                lambda: MandreUI.show(
                    self._t("update_title"),
                    [self._t("update_yes"), self._t("update_later")],
                    on_select,
                    message=msg,
                )
            )

    def _check_updates(self, manual=False, silent=False):
        self._maybe_update(
            self.id,
            "EtgBridge.plugin",
            __version__,
            manual=manual,
            silent=silent,
        )
        mandre_ver = self._get_plugin_version("mandre_lib", "")
        if mandre_ver:
            self._maybe_update(
                "mandre_lib",
                "mandre_lib.plugin",
                mandre_ver,
                manual=manual,
                silent=silent,
            )

    def _start_worker(self):
        if self._thread and self._thread.is_alive():
            return
        self._stop.clear()
        self._thread = threading.Thread(target=self._poll_loop, daemon=True)
        self._thread.start()

    def _poll_loop(self):
        while not self._stop.is_set():
            if not self.get_setting("enabled", True):
                self._close_ws()
                time.sleep(1)
                continue
            ws_ok = self._sync_ws_tick()
            if not ws_ok:
                interval = int(self.get_setting("poll_interval", 3))
                now = time.time()
                if now - self._ws_last_http >= max(1, interval):
                    try:
                        self._sync_http()
                    except Exception as exc:
                        self._queue_log(f"sync crash: {exc}")
                    self._ws_last_http = now
            time.sleep(0.2)

    def _force_sync(self):
        try:
            ws_ok = self._sync_ws_tick(force=True)
            if not ws_ok:
                self._sync_http()
        except Exception as exc:
            self._queue_log(f"sync failed: {exc}")

    def _queue_log(self, text):
        ts = time.time()
        with self._lock:
            self._pending_logs.append({"ts": ts, "text": str(text)})
            self._pending_logs = self._pending_logs[-400:]
        self.log(str(text))

    def _queue_result(self, result):
        with self._lock:
            self._pending_results.append(result)
            self._pending_results = self._pending_results[-400:]

    def _drain_logs(self):
        with self._lock:
            logs = list(self._pending_logs)
            self._pending_logs.clear()
        return logs

    def _drain_results(self):
        with self._lock:
            results = list(self._pending_results)
            self._pending_results.clear()
        return results

    def _format_status(self):
        server_url = self._get_server_url()
        ws_url = self._get_ws_url()
        status = self._last_status
        error = self._last_error
        transport = self._last_transport
        if error:
            return f"{status} | {transport} | {server_url} | {error}"
        if transport == "ws":
            return f"{status} | ws | {ws_url}"
        return f"{status} | http | {server_url}"

    def _collect_info(self):
        info = MandreDevice.get_device_info()
        return {
            "device_name": info.get("manufacturer", ""),
            "device_model": info.get("model", ""),
            "android_version": info.get("android_version", ""),
            "api_level": info.get("api_level", ""),
            "simple": MandreDevice.get_simple_info(),
            "plugin_version": __version__,
        }

    def _build_payload(self):
        return {
            "device_id": self.get_setting("device_id", ""),
            "token": (self.get_setting("auth_token", "") or "").strip(),
            "info": self._collect_info(),
            "logs": self._drain_logs(),
            "results": self._drain_results(),
            "ts": int(time.time() * 1000),
        }

    def _handle_server_message(self, data):
        if not isinstance(data, dict):
            return
        actions = data.get("actions") or []
        if isinstance(actions, list):
            for action in actions:
                if isinstance(action, dict):
                    self._run_action(action)

    def _sync_http(self):
        server_url = self._get_server_url()
        if not server_url:
            self._last_status = "no server url"
            return
        payload = self._build_payload()
        try:
            try:
                requests.packages.urllib3.disable_warnings()  # type: ignore[attr-defined]
            except Exception:
                pass
            resp = requests.post(server_url, json=payload, timeout=20, verify=False)
        except Exception as exc:
            self._last_status = "offline"
            self._last_error = str(exc)
            self._last_transport = "http"
            self._queue_log(f"request error: {exc}")
            return
        if resp.status_code != 200:
            self._last_status = f"bad_http_{resp.status_code}"
            self._last_error = resp.text[:200]
            self._last_transport = "http"
            self._queue_log(f"http {resp.status_code}: {resp.text[:200]}")
            return
        try:
            data = resp.json()
        except Exception as exc:
            self._last_status = "bad_json"
            self._last_error = str(exc)
            self._last_transport = "http"
            self._queue_log(f"bad json: {exc}")
            return
        self._last_status = "online"
        self._last_error = ""
        self._last_transport = "http"
        self._handle_server_message(data)

    def _close_ws(self):
        ws = self._ws
        self._ws = None
        if ws:
            try:
                ws.close()
            except Exception:
                pass

    def _ensure_ws(self):
        ws_url = self._get_ws_url()
        if not ws_url:
            return None
        now = time.time()
        if now < self._ws_backoff_until:
            return None
        if self._ws and self._ws.alive:
            return self._ws
        self._close_ws()
        try:
            self._ws = _WSClient(ws_url)
            self._ws_next_sync = 0.0
            self._ws_last_ping = 0.0
            self._ws_failures = 0
            self._ws_backoff_until = 0.0
            return self._ws
        except Exception as exc:
            self._ws_failures += 1
            delay = min(60, 2 ** min(self._ws_failures, 6))
            self._ws_backoff_until = now + delay
            self._last_status = "offline"
            self._last_error = str(exc)
            self._last_transport = "ws"
            if now - self._ws_last_error_at >= 2:
                self._queue_log(f"ws connect error: {exc}")
                self._ws_last_error_at = now
            self._close_ws()
            return None

    def _sync_ws_tick(self, force=False):
        ws = self._ensure_ws()
        if not ws:
            if force:
                self._sync_http()
            return False
        now = time.time()
        interval = max(1, int(self.get_setting("poll_interval", 3)))
        if force or now >= self._ws_next_sync:
            payload = self._build_payload()
            try:
                ws.send_json(payload)
                self._ws_next_sync = now + interval
                self._last_status = "online"
                self._last_error = ""
                self._last_transport = "ws"
            except Exception as exc:
                self._queue_log(f"ws send error: {exc}")
                self._last_status = "offline"
                self._last_error = str(exc)
                self._last_transport = "ws"
                self._close_ws()
                return False
        self._drain_ws_messages(ws, max_wait=0.25)
        ping_interval = max(5, int(self.get_setting("ws_ping_interval", 20)))
        if now - self._ws_last_ping >= ping_interval:
            try:
                ws.send_ping()
                self._ws_last_ping = now
            except Exception as exc:
                self._queue_log(f"ws ping error: {exc}")
                self._close_ws()
                return False
        return True

    def _drain_ws_messages(self, ws, max_wait=0.25):
        end = time.time() + max_wait
        while time.time() < end and ws.alive:
            try:
                msg = ws.recv_text(timeout=0.2)
            except Exception as exc:
                self._queue_log(f"ws recv error: {exc}")
                self._close_ws()
                return
            if msg is None:
                return
            if not msg:
                continue
            try:
                data = json.loads(msg)
            except Exception as exc:
                self._queue_log(f"ws bad json: {exc}")
                continue
            self._last_status = "online"
            self._last_error = ""
            self._last_transport = "ws"
            self._handle_server_message(data)

    def _run_action(self, action):
        action_id = str(action.get("id") or "")
        name = str(action.get("action") or "")
        payload = action.get("payload") or {}
        if not action_id or not name:
            return
        handler = getattr(self, f"_action_{name}", None)
        try:
            if handler is None:
                raise ValueError(f"unknown action: {name}")
            data = handler(payload, action_id)
            result = {
                "id": action_id,
                "ok": True,
                "action": name,
                "data": data,
            }
        except Exception as exc:
            result = {
                "id": action_id,
                "ok": False,
                "action": name,
                "error": f"{exc}",
                "trace": traceback.format_exc(limit=4),
            }
            self._queue_log(f"action {name} failed: {exc}")
        self._queue_result(result)

    def _action_toast(self, payload, action_id):
        text = str(payload.get("text") or "")
        if not text:
            return {"shown": False}
        run_on_ui_thread(lambda: BulletinHelper.show_info(text))
        return {"shown": True}

    def _action_dialog(self, payload, action_id):
        title = str(payload.get("title") or "ETG Bridge")
        message = str(payload.get("text") or payload.get("message") or "")
        buttons = payload.get("buttons") or ["OK"]
        callback_id = payload.get("callback_id") or f"{action_id}:choice"

        def on_select(index, text):
            self._queue_result(
                {
                    "id": callback_id,
                    "ok": True,
                    "action": "dialog_choice",
                    "data": {"index": index, "text": text},
                }
            )

        def show():
            MandreUI.show(
                title=title,
                items=[str(x) for x in buttons],
                on_select=on_select,
                message=message,
                cancel_text=self._t("close"),
            )

        run_on_ui_thread(show)
        return {"shown": True, "callback_id": callback_id}

    def _action_menu(self, payload, action_id):
        title = str(payload.get("title") or "Menu")
        message = str(payload.get("message") or "")
        items = payload.get("items") or []
        callback_id = payload.get("callback_id") or f"{action_id}:choice"

        def on_select(index, text):
            item_id = None
            if index < len(items):
                item = items[index]
                if isinstance(item, dict):
                    item_id = item.get("id")
            self._queue_result(
                {
                    "id": callback_id,
                    "ok": True,
                    "action": "menu_choice",
                    "data": {"index": index, "id": item_id, "text": text},
                }
            )

        labels = []
        for item in items:
            if isinstance(item, dict):
                labels.append(str(item.get("text") or item.get("id") or "item"))
            else:
                labels.append(str(item))

        run_on_ui_thread(
            lambda: MandreUI.show(
                title=title,
                items=labels,
                on_select=on_select,
                message=message,
                cancel_text=self._t("close"),
            )
        )
        return {"shown": True, "callback_id": callback_id}

    def _action_prompt(self, payload, action_id):
        title = str(payload.get("title") or "–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç")
        hint = str(payload.get("hint") or "")
        text = str(payload.get("text") or "")
        multiline = bool(payload.get("multiline", True))
        max_len = int(payload.get("max_len") or 0)
        callback_id = payload.get("callback_id") or f"{action_id}:prompt"

        def send_result(value, cancel=False):
            self._queue_result(
                {
                    "id": callback_id,
                    "ok": not cancel,
                    "action": "prompt",
                    "data": {"text": value, "cancel": bool(cancel)},
                }
            )

        def show():
            fragment = get_last_fragment()
            activity = fragment.getParentActivity() if fragment else None
            if not activity:
                send_result("", cancel=True)
                return

            pad = AndroidUtilities.dp(16) if AndroidUtilities else 24
            layout = LinearLayout(activity)
            layout.setOrientation(LinearLayout.VERTICAL)
            layout.setPadding(pad, pad, pad, pad)

            edit = EditText(activity)
            edit.setHint(hint)
            edit.setText(text)
            if multiline:
                edit.setSingleLine(False)
                edit.setMinLines(4)
                edit.setGravity(Gravity.TOP | Gravity.START)
                edit.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_FLAG_MULTI_LINE)
            else:
                edit.setSingleLine(True)
                edit.setInputType(InputType.TYPE_CLASS_TEXT)

            if max_len > 0:
                try:
                    LengthFilter = find_class("android.text.InputFilter$LengthFilter")
                    edit.setFilters([LengthFilter(int(max_len))])
                except Exception:
                    pass

            scroll = ScrollView(activity)
            scroll.addView(edit)
            layout.addView(scroll)

            builder = AlertDialogBuilder(activity)
            builder.set_title(title)
            builder.set_view(layout)
            builder.set_positive_button(
                self._t("ok"), lambda d, w: send_result(edit.getText().toString())
            )
            builder.set_negative_button(
                self._t("cancel"),
                lambda d, w: send_result("", cancel=True),
            )
            builder.show()

        run_on_ui_thread(show)
        return {"shown": True, "callback_id": callback_id}

    def _action_open_editor(self, payload, action_id):
        title = str(payload.get("title") or "Editor")
        filename = str(payload.get("filename") or "")
        content = str(payload.get("content") or "")
        readonly = bool(payload.get("readonly", False))
        callback_id = payload.get("callback_id") or f"{action_id}:editor"
        full_title = f"{title} ‚Äî {filename}" if filename else title

        def send_result(value, cancel=False):
            self._queue_result(
                {
                    "id": callback_id,
                    "ok": not cancel,
                    "action": "editor_save",
                    "data": {
                        "text": value,
                        "filename": filename,
                        "cancel": bool(cancel),
                    },
                }
            )

        def copy_text(value):
            ctx = ApplicationLoader.applicationContext
            clipboard = ctx.getSystemService("clipboard") if ctx else None
            if clipboard:
                clip = ClipData.newPlainText("etg_editor", value)
                clipboard.setPrimaryClip(clip)
                BulletinHelper.show_info("–°–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ")

        def show():
            fragment = get_last_fragment()
            activity = fragment.getParentActivity() if fragment else None
            if not activity:
                send_result("", cancel=True)
                return

            pad = AndroidUtilities.dp(16) if AndroidUtilities else 24
            layout = LinearLayout(activity)
            layout.setOrientation(LinearLayout.VERTICAL)
            layout.setPadding(pad, pad, pad, pad)

            edit = EditText(activity)
            edit.setText(content)
            edit.setSingleLine(False)
            edit.setMinLines(10)
            edit.setGravity(Gravity.TOP | Gravity.START)
            edit.setInputType(
                InputType.TYPE_CLASS_TEXT
                | InputType.TYPE_TEXT_FLAG_MULTI_LINE
                | InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS
            )
            if readonly:
                edit.setKeyListener(None)
                edit.setFocusable(False)
                edit.setFocusableInTouchMode(False)

            scroll = ScrollView(activity)
            scroll.addView(edit)
            layout.addView(scroll)

            builder = AlertDialogBuilder(activity)
            builder.set_title(full_title)
            builder.set_view(layout)
            if not readonly:
                builder.set_positive_button(
                    "–°–æ—Ö—Ä–∞–Ω–∏—Ç—å", lambda d, w: send_result(edit.getText().toString())
                )
            builder.set_neutral_button(
                "–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å", lambda d, w: copy_text(edit.getText().toString())
            )
            builder.set_negative_button("–ó–∞–∫—Ä—ã—Ç—å", lambda d, w: send_result("", cancel=True))
            builder.show()

        run_on_ui_thread(show)
        return {"shown": True, "callback_id": callback_id}

    def _action_show(self, payload, action_id):
        title = str(payload.get("title") or "–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ")
        message = str(payload.get("message") or "")
        items = payload.get("items") or []
        callback_id = payload.get("callback_id") or f"{action_id}:choice"

        labels = []
        for item in items:
            if isinstance(item, dict):
                labels.append(str(item.get("text") or item.get("id") or "item"))
            else:
                labels.append(str(item))

        def on_select(index, text):
            item_id = None
            if index < len(items):
                item = items[index]
                if isinstance(item, dict):
                    item_id = item.get("id")
            self._queue_result(
                {
                    "id": callback_id,
                    "ok": True,
                    "action": "show_choice",
                    "data": {"index": index, "id": item_id, "text": text},
                }
            )

        run_on_ui_thread(
            lambda: MandreUI.show(
                title=title,
                items=labels,
                on_select=on_select,
                message=message,
                cancel_text="–û—Ç–º–µ–Ω–∞",
            )
        )
        return {"shown": True, "callback_id": callback_id}

    def _action_sheet(self, payload, action_id):
        dsl = str(payload.get("dsl") or payload.get("markup") or "")
        actions = payload.get("actions") or []
        callback_id = payload.get("callback_id") or f"{action_id}:sheet"
        sheet_id = str(payload.get("sheet_id") or action_id)
        callbacks = self._build_sheet_callbacks(actions, callback_id)

        def show():
            controller = MandreUI.show_bottom_sheet(self, dsl, callbacks)
            with self._sheet_lock:
                self._sheets[sheet_id] = controller

        run_on_ui_thread(show)
        return {"shown": True, "callback_id": callback_id, "sheet_id": sheet_id}

    def _action_sheet_update(self, payload, action_id):
        sheet_id = str(payload.get("sheet_id") or "")
        dsl = str(payload.get("dsl") or payload.get("markup") or "")
        if not sheet_id or not dsl:
            return {"updated": False}
        actions = payload.get("actions") or []
        callback_id = payload.get("callback_id") or f"{action_id}:sheet"
        callbacks = self._build_sheet_callbacks(actions, callback_id)

        with self._sheet_lock:
            controller = self._sheets.get(sheet_id)
        if not controller:
            return self._action_sheet(payload, action_id)

        def update():
            try:
                controller.update(dsl, callbacks)
            except Exception as exc:
                self._queue_log(f"sheet update failed: {exc}")

        run_on_ui_thread(update)
        return {"updated": True, "sheet_id": sheet_id}

    def _action_sheet_close(self, payload, action_id):
        sheet_id = str(payload.get("sheet_id") or "")
        if not sheet_id:
            return {"closed": False}
        with self._sheet_lock:
            controller = self._sheets.pop(sheet_id, None)
        if controller:
            run_on_ui_thread(lambda: controller.dismiss())
        return {"closed": True, "sheet_id": sheet_id}

    def _build_sheet_callbacks(self, actions, callback_id):
        callbacks = {}
        for item in actions:
            if isinstance(item, dict):
                item_id = str(item.get("id") or item.get("text") or "")
            else:
                item_id = str(item)
            if not item_id:
                continue

            def handler(controller=None, item_id=item_id):
                self._queue_result(
                    {
                        "id": callback_id,
                        "ok": True,
                        "action": "sheet_action",
                        "data": {"id": item_id},
                    }
                )

            callbacks[item_id] = handler
        return callbacks

    def _action_ripple(self, payload, action_id):
        intensity = float(payload.get("intensity") or 1.0)
        vibrate = bool(payload.get("vibrate", True))
        run_on_ui_thread(lambda: MandreUI.ripple(intensity=intensity, vibrate=vibrate))
        return {"shown": True}

    def _action_select_chat(self, payload, action_id):
        title = str(payload.get("title") or "–í—ã–±–µ—Ä–∏—Ç–µ —á–∞—Ç")
        callback_id = payload.get("callback_id") or f"{action_id}:chat"

        def on_select(chat_info):
            data = {
                "id": chat_info.get("id"),
                "title": chat_info.get("title"),
            }
            self._queue_result(
                {
                    "id": callback_id,
                    "ok": True,
                    "action": "select_chat",
                    "data": data,
                }
            )

        run_on_ui_thread(
            lambda: MandreUI.select_chat(
                title=title,
                on_select=on_select,
                search_hint="–ü–æ–∏—Å–∫ —á–∞—Ç–∞...",
                cancel_text="–û—Ç–º–µ–Ω–∞",
            )
        )
        return {"shown": True, "callback_id": callback_id}

    def _action_open_url(self, payload, action_id):
        url = str(payload.get("url") or "")
        if not url:
            return {"opened": False}
        ctx = ApplicationLoader.applicationContext
        intent = Intent(Intent.ACTION_VIEW, Uri.parse(url))
        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
        run_on_ui_thread(lambda: ctx.startActivity(intent))
        return {"opened": True}

    def _action_clipboard_set(self, payload, action_id):
        text = str(payload.get("text") or "")
        ctx = ApplicationLoader.applicationContext
        clipboard = ctx.getSystemService("clipboard")
        if clipboard:
            clip = ClipData.newPlainText("etg_bridge", text)
            clipboard.setPrimaryClip(clip)
        return {"ok": True}

    def _action_clipboard_get(self, payload, action_id):
        ctx = ApplicationLoader.applicationContext
        clipboard = ctx.getSystemService("clipboard")
        if not clipboard:
            return {"text": ""}
        data = clipboard.getPrimaryClip()
        if data and data.getItemCount() > 0:
            item = data.getItemAt(0)
            return {"text": str(item.getText() or "")}
        return {"text": ""}

    def _action_notify(self, payload, action_id):
        title = str(payload.get("title") or "ETG Bridge")
        text = str(payload.get("text") or "")
        MandreNotification.show_simple(title=title, text=text, channel_id="etg_bridge")
        return {"shown": True}

    def _action_notify_dialog(self, payload, action_id):
        sender = str(payload.get("sender_name") or "ETG Bridge")
        message = str(payload.get("message") or "")
        avatar = str(payload.get("avatar_url") or "")
        MandreNotification.show_dialog(
            sender_name=sender,
            message=message,
            avatar_url=avatar,
            channel_id="etg_bridge_dialogs",
        )
        return {"shown": True}

    def _action_tts(self, payload, action_id):
        text = str(payload.get("text") or "")
        if text:
            MandreTTS.speak(text)
        return {"spoken": bool(text)}

    def _action_share_text(self, payload, action_id):
        text = str(payload.get("text") or "")
        title = str(payload.get("title") or "Share")
        MandreShare.share_text(text=text, title=title)
        return {"shared": True}

    def _action_share_file(self, payload, action_id):
        path = str(payload.get("path") or "")
        title = str(payload.get("title") or "Share")
        if not path:
            return {"shared": False}
        MandreShare.share_file(path, title)
        return {"shared": True}

    def _action_send_png(self, payload, action_id):
        url = str(payload.get("url") or "")
        caption = str(payload.get("caption") or "")
        if not url:
            return {"sent": False}
        try:
            resp = requests.get(url, timeout=20)
            resp.raise_for_status()
            fd, path = tempfile.mkstemp(prefix="etg_", suffix=".png")
            os.close(fd)
            with open(path, "wb") as handle:
                handle.write(resp.content)
            MandreSend.png(path, caption)
            return {"sent": True}
        except Exception as exc:
            raise RuntimeError(str(exc))

    def _action_render_html(self, payload, action_id):
        html = str(payload.get("html") or "")
        if not html:
            return {"rendered": False}
        width = int(payload.get("width") or 1024)
        height = int(payload.get("height") or 768)
        bg = payload.get("bg_color") or (26, 30, 36)
        prefix = str(payload.get("file_prefix") or "etg_")
        send = bool(payload.get("send", False))
        caption = str(payload.get("caption") or "")

        def on_result(success, result_path):
            if success and send:
                try:
                    MandreSend.png(result_path, caption)
                except Exception as exc:
                    self._queue_log(f"send png failed: {exc}")
            self._queue_result(
                {
                    "id": action_id,
                    "ok": bool(success),
                    "action": "render_html",
                    "data": {"path": result_path} if success else None,
                    "error": None if success else str(result_path),
                }
            )

        run_on_ui_thread(
            lambda: MandreWeb.render_html_to_png(
                html=html,
                on_result=on_result,
                width=width,
                height=height,
                bg_color=tuple(bg),
                file_prefix=prefix,
            )
        )
        return {"rendered": True}

    def _action_device_info(self, payload, action_id):
        return self._collect_info()

    def _action_recent_messages(self, payload, action_id):
        dialog_id = payload.get("dialog_id")
        limit = int(payload.get("limit") or 20)
        if not dialog_id:
            return {"messages": []}
        messages = MandreMessages.get_local(int(dialog_id), limit)
        out = []
        for msg in messages:
            text = getattr(msg, "message", "") or ""
            out.append({"id": getattr(msg, "id", 0), "text": text})
        return {"messages": out}

    def _action_data_write(self, payload, action_id):
        filename = str(payload.get("filename") or "data.json")
        data = payload.get("data", {})
        MandreData.write_persistent_json(self.id, filename, data)
        return {"ok": True}

    def _action_data_read(self, payload, action_id):
        filename = str(payload.get("filename") or "data.json")
        data = MandreData.read_persistent_json(self.id, filename, default={})
        return {"data": data}

    def _action_data_list(self, payload, action_id):
        files = MandreData.list_files_for_plugin(self.id)
        return {"files": files}

    def _action_data_delete(self, payload, action_id):
        MandreData.delete_persistent_plugin_data(self.id)
        return {"ok": True}

    def _action_kv_set(self, payload, action_id):
        key = str(payload.get("key") or "")
        value = payload.get("value")
        table = str(payload.get("table") or "etg_bridge")
        Mandre.sql_kv_set(self.id, key, value, table)
        return {"ok": True}

    def _action_kv_get(self, payload, action_id):
        key = str(payload.get("key") or "")
        table = str(payload.get("table") or "etg_bridge")
        value = Mandre.sql_kv_get(self.id, key, table)
        return {"value": value}

    def _action_kv_get_int(self, payload, action_id):
        key = str(payload.get("key") or "")
        table = str(payload.get("table") or "etg_bridge")
        default = int(payload.get("default") or 0)
        value = Mandre.sql_kv_get_int(self.id, key, default, table)
        return {"value": value}

    def _action_kv_delete_prefix(self, payload, action_id):
        prefix = str(payload.get("prefix") or "")
        table = str(payload.get("table") or "etg_bridge")
        Mandre.sql_kv_delete_prefix(self.id, prefix, table)
        return {"ok": True}

    def _action_pip_install(self, payload, action_id):
        packages = payload.get("packages") or payload.get("package") or ""
        if isinstance(packages, str) and packages:
            packages = [packages]
        if not packages:
            return {"ok": False}
        result = MandreInstall(packages)
        return {"ok": bool(result)}

    def _action_exec(self, payload, action_id):
        code = str(payload.get("code") or "")
        if not code:
            return {"executed": False}
        scope = {
            "plugin": self,
            "Mandre": Mandre,
            "MandreUI": MandreUI,
            "MandreDevice": MandreDevice,
            "MandreNotification": MandreNotification,
            "MandreShare": MandreShare,
            "MandreSend": MandreSend,
            "MandreTTS": MandreTTS,
            "MandreWeb": MandreWeb,
            "MandreMessages": MandreMessages,
        }
        exec(code, scope, scope)
        result = scope.get("result")
        return {"executed": True, "result": result}
